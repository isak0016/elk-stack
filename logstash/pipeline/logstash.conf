#INPUT FROM GCP
input {
  google_pubsub {
    project_id => "betterwse-analytics"
    #topic => "cloudrun-metrics-logs"
    topic => "log-topic-001"
    #subscription => "logstash-cloudrun-metric"
    subscription => "logstash-central-logs-sub-001"
    #json_key_file => "/usr/share/logstash/key/logkey.json"
    include_metadata => false 
    tags => ["from_gcp"]
  }
}
filter { 

  #PARSING MESSAGE FIELD INTO FIELDS
  json {
    source => "message"
    target => "parsed_message"
    remove_field => ["message"]
    ecs_compatibility => disabled 
  }

  #FLATTENING LENGTHY "parsed_message.*" FIELDS
  ruby {
    code => '
      def flatten_hash(h, parent_key = "", result = {})
        h.each do |k, v|
          key = parent_key == "" ? k : "#{parent_key}.#{k}"
          if v.is_a?(Hash)
            flatten_hash(v, key, result)
          else
            result[key] = v
          end
        end
        result
      end

      if event.get("parsed_message").is_a?(Hash)
        flat = flatten_hash(event.get("parsed_message"))
        flat.each { |k, v| event.set(k, v) }
        event.remove("parsed_message")
      end
    '
    ecs_compatibility => disabled
  }
  #EXTRACT EVERY NUMBER FROM textPayload
  ruby {
    code => '
      tp = event.get("textPayload")
      next if tp.nil?

      tp.scan(/(\d+(?:\.\d+)?)/).flatten.each do |num|
        normalized = tp.gsub(num, "<NUM>")

        field_name = "var_" + Digest::SHA1.hexdigest(normalized)[0..8]

        value = num.include?(".") ? num.to_f : num.to_i

        event.set(field_name, value)
      end
    '
  }

  #REPLACING LOGSTASH CREATED TIMESTAMP WITH ORIGINAL ONE
  date {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
    timezone => "UTC"
  }

  #LIST OF FIELDS TO REMOVE
  mutate {
    remove_field => [
      "event",
      "event.original",
      "event.original.keyword",
      "version",
      "insertId",
      "resource.labels.destination",
      "research.labels.name",
      "resource.labels.instance_id",
      "resource.labels.instance.id",
      "resource.labels.database_id",
      "resource.labels.location",
      "resource.labels.region",
      "httpRequest.protocol",
      "httpRequest.referer",
      "spanId",
      "@version",
      "traceSampled",
      "trace",
      "jsonPayload.targetType",
      "jsonPayload.records",
      "jsonPayload.container.id",
      "jsonPayload.instance.id",
      "jsonPayload.container.imageName",
      "jsonPayload.container.imageId",
      "jsonPayload.container.instance.name",
      "jsonPayload.container.name",
      "labels.execution_id",
      "labels.instance_id",
      "resource.labels.service_name",
      "resource.labels.revision_name",
      "timestamp",
      "receiveTimestamp",
      "labels.INSTANCE_UID",
      "labels.LOG_BUCKET_NUM",
      "labels.PROJECT_NUMBER",
      "labels.SOURCE_ID"
    ]
  }
}

#OUTPUT TO ES
output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "from_gcp"
    manage_template => false
    ilm_enabled => false
  }
  stdout { codec => rubydebug }
}
